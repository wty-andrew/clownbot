(self.webpackChunkclownbot_website=self.webpackChunkclownbot_website||[]).push([[606],{3359:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return r},metadata:function(){return o},toc:function(){return l},default:function(){return u}});var a=n(2122),i=n(9756),s=(n(7294),n(3905)),r={title:"Testing Setup"},o={permalink:"/clownbot/blog/2020/05/10/testing-setup",source:"@site/blog/2020-05-10-testing-setup.md",title:"Testing Setup",description:"It seems the roslisptesting package mentioned in ros wiki no longer exist anymore. However, the wiki page provide detailed enough information so we can roll our own solution, here are some notes taken while trying to replicate the functionality.",date:"2020-05-10T00:00:00.000Z",formattedDate:"May 10, 2020",tags:[],readingTime:4.135,truncated:!0},l=[{value:"Integration with Rostest",id:"integration-with-rostest",children:[]},{value:"Executable Script",id:"executable-script",children:[]},{value:"Integration with Catkin",id:"integration-with-catkin",children:[]}],p={toc:l};function u(e){var t=e.components,n=(0,i.Z)(e,["components"]);return(0,s.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"It seems the ",(0,s.kt)("inlineCode",{parentName:"p"},"roslisp_testing")," package mentioned in ",(0,s.kt)("a",{parentName:"p",href:"http://wiki.ros.org/roslisp_support/Tutorials/UnitTestingwithRT"},"ros wiki")," no longer exist anymore. However, the wiki page provide detailed enough information so we can roll our own solution, here are some notes taken while trying to replicate the functionality."),(0,s.kt)("h2",{id:"integration-with-rostest"},"Integration with Rostest"),(0,s.kt)("p",null,"In order to make our own test compliant with rostest, we need to convert the test result into google test compatible format, which actually uses the JUnit XML format",(0,s.kt)("sup",{parentName:"p",id:"fnref-1"},(0,s.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),"."),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"http://wiki.ros.org/roslisp_support/Tutorials/UnitTestingwithRT#Other_test_frameworks"},"wiki")," page already provide the structure templates and the function signature of the entry point"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-lisp"},"(defstruct gtestfailure\n  type ;; string\n  message ;; string\n  )\n\n(defstruct gtestcase\n  classname ;; string\n  name ;; string\n  time ;; float\n  failures ;; list of gtestfailure\n  )\n\n(defstruct gtestsuite\n  name ;; string\n  time ;; float\n  testcases ;; list of gtestcase\n  sysout ;; string\n  syserr ;; string\n  )\n\n(defun run-suites-write-gtest-file (posix-args suite-fun transform-fun)\n  ...)\n")),(0,s.kt)("p",null,"To fill in the ",(0,s.kt)("inlineCode",{parentName:"p"},"run-suites-write-gtest-file"),", we need a function to convert the structures to something like below"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-xml"},'<testsuites name="AllTests" ...>\n  <testsuite name="test_case_name" ...>\n    <testcase name="test_name" ...>\n      <failure message="..."/>\n      <failure message="..."/>\n      <failure message="..."/>\n    </testcase>\n  </testsuite>\n</testsuites>\n')),(0,s.kt)("p",null,"and a function to find out xml output path from ",(0,s.kt)("inlineCode",{parentName:"p"},"posix-args")," (rostest will pass it through the ",(0,s.kt)("inlineCode",{parentName:"p"},"--gtest_output")," flag)."),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"suite-fun")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"tranform-fun")," are customized functions for the testing framework being used"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"suite-fun")," runs the tests and returns a test result object"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"tranform-fun")," converts the test result object into the ",(0,s.kt)("inlineCode",{parentName:"li"},"gtestsuite")," structure")),(0,s.kt)("p",null,"A minimal implementation for ",(0,s.kt)("inlineCode",{parentName:"p"},"run-suites-write-gtest-file")," would be"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-lisp"},"(defun run-suites-write-gtest-file (posix-args suite-fun transform-fun)\n  (let* ((output-path (find-gtest-output-path posix-args)\n         (test-results (funcall suite-fun))\n         (gtest-results (funcall transform-fun test-results))\n    (with-open-file (*standard-output* output-path :direction :output\n                                                   :if-exists :supersede)\n      (gtest->xml gtest-results))))))\n")),(0,s.kt)("p",null,"For a practical example, suppose we want to run it with ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/OdonataResearchLLC/lisp-unit"},"lisp-unit"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"suite-fun")," will be the function to run the tests: ",(0,s.kt)("inlineCode",{parentName:"p"},"(lambda () (lisp-unit:run-tests :all :my-package))"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"transform-fun")," can be implemented by converting the following objects"),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"lisp-unit"),(0,s.kt)("th",{parentName:"tr",align:null},"gtest"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"failure")),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"gtestfailure"))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"test-result")),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"gtestcase"))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"test-results-db")),(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"gtestsuite"))))),(0,s.kt)("p",null,"the one-to-one correspondence is not a coincidence since ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/OdonataResearchLLC/lisp-unit"},"lisp-unit")," claimed to be inspired by JUnit, the ",(0,s.kt)("inlineCode",{parentName:"p"},"transform-fun")," happened to be quite trivial in this case."),(0,s.kt)("h2",{id:"executable-script"},"Executable Script"),(0,s.kt)("p",null,"The ros wiki page on ",(0,s.kt)("a",{parentName:"p",href:"http://wiki.ros.org/roslisp/Tutorials/OrganizingFiles"},"organizing files for roslisp")," have thorough information on creating lisp executable scripts, the easiest way is to use the cmake function"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cmake",metastring:'title="catkin_ws/src/my_package/CMakeLists.txt"',title:'"catkin_ws/src/my_package/CMakeLists.txt"'},"# the function arguments are output, system_name, and entry_point respectively\nadd_lisp_executable(my_node my-system my-package:my-func)\n")),(0,s.kt)("p",null,"which should generate the following script"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash",metastring:'title="catkin_ws/devel/lib/my_package/my_node" {2}',title:'"catkin_ws/devel/lib/my_package/my_node"',"{2}":!0},'#!/usr/bin/env sh\n"true"; exec /usr/bin/env sbcl --noinform --load /opt/ros/melodic/share/roslisp/scripts/roslisp-sbcl-init --script "$0" "$@"\n\n(ros-load:load-system "my_package" "my-system")\n(my-package:my-func)\n')),(0,s.kt)("p",null,"The script will first be run by shell and then ",(0,s.kt)("inlineCode",{parentName:"p"},"sbcl"),", the highlighted line shows a clever trick, ",(0,s.kt)("inlineCode",{parentName:"p"},'"true"')," and the semicolon are both valid syntax for ",(0,s.kt)("inlineCode",{parentName:"p"},"sh")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"sbcl"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"sbcl")," ignores shebang by default so the entire script is a valid lisp script (",(0,s.kt)("inlineCode",{parentName:"p"},'"true"')," just evaluates to a string which does no harm)."),(0,s.kt)("p",null,"Another trick found from ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/roswell/roswell"},"roswell")," uses block comments, in addition, the mode line will inform emacs to choose the correct mode for editing"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash",metastring:"{2}","{2}":!0},'#!/usr/bin/env sh\n#|-*- mode:lisp -*-|#\n#|\nexec /usr/bin/env sbcl --noinform --script "$0" "$@"\n|#\n')),(0,s.kt)("p",null,"Now back to the lisp executable script, notice there's only a single entry function that takes no arguments, so a wrapper function is required if we are going to run ",(0,s.kt)("inlineCode",{parentName:"p"},"run-suites-write-gtest-file"),". The other problem is ",(0,s.kt)("inlineCode",{parentName:"p"},"sbcl")," does not load ",(0,s.kt)("inlineCode",{parentName:"p"},".sbclrc")," when running with ",(0,s.kt)("inlineCode",{parentName:"p"},"--script")," option (according to ",(0,s.kt)("a",{parentName:"p",href:"https://stackoverflow.com/questions/9229526"},"this discussion")," on stackoverflow), we have to load ",(0,s.kt)("inlineCode",{parentName:"p"},"quicklisp")," ourselves in order to use external libraries."),(0,s.kt)("p",null,"Here's the final modified template for lisp executable script"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'#!/usr/bin/env sh\n#|-*- mode:lisp -*-|#\n#|\nexec /usr/bin/env sbcl --noinform \\\n                       --load $(rospack find roslisp)/scripts/roslisp-sbcl-init \\\n                       --load $HOME/quicklisp/setup.lisp \\\n                       --script "$0" "$@"\n|#\n\n(ros-load:load-system "my_package" "my-system")\n(my-package:my-func)\n')),(0,s.kt)("p",null,"To automate the script generation process, the ",(0,s.kt)("inlineCode",{parentName:"p"},"add_lisp_executable")," function (see ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/ros/roslisp/blob/master/cmake/roslisp-extras.cmake.em"},"roslisp-extras.cmake.em"),") is copied and named ",(0,s.kt)("inlineCode",{parentName:"p"},"add_lisp_script")," in the project."),(0,s.kt)("h2",{id:"integration-with-catkin"},"Integration with Catkin"),(0,s.kt)("p",null,"It would be great if our lisp test can be invoked automatically when running the ",(0,s.kt)("inlineCode",{parentName:"p"},"catkin_make run_tests")," command, this is done in python and C++ through the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/ros/catkin/blob/noetic-devel/cmake/test/nosetests.cmake"},"catkin_add_nosetests")," and ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/ros/catkin/blob/noetic-devel/cmake/test/gtest.cmake"},"catkin_add_gmock")," cmake function, they use the internal function ",(0,s.kt)("inlineCode",{parentName:"p"},"catkin_run_tests_target")," to add in the dependency."),(0,s.kt)("p",null,"Combined with the ",(0,s.kt)("inlineCode",{parentName:"p"},"add_lisp_script")," from the above section, here's the new ",(0,s.kt)("inlineCode",{parentName:"p"},"catkin_add_lisptests")," cmake function"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cmake"},'_generate_function_if_testing_is_disabled("catkin_add_lisptests")\n\nfunction(catkin_add_lisptests filename system_name entry_point)\n  if(NOT ${ARGC} EQUAL 3)\n    message(FATAL_ERROR "catkin_add_lisptests can only have 3 arguments")\n  endif()\n\n  cmake_parse_arguments(ARG "" "TIMEOUT;WORKING_DIRECTORY" "" ${ARGN})\n  if(ARG_TIMEOUT)\n    message(WARNING "TIMEOUT argument to catkin_add_lisptests() is ignored")\n  endif()\n\n  add_lisp_script(${filename} ${system_name} ${entry_point})\n\n  set(output_dir ${CATKIN_DEVEL_PREFIX}/${CATKIN_PACKAGE_BIN_DESTINATION})\n  set(script ${output_dir}/${filename})\n  set(target _roslisp_${filename})\n  set(test_output_dir ${CATKIN_TEST_RESULTS_DIR}/${PROJECT_NAME})\n  set(xunit_filename lisptests-${filename}.xml)\n  add_dependencies(tests ${target})\n\n  file(MAKE_DIRECTORY ${test_output_dir})\n\n  catkin_run_tests_target("lisptests" ${target} ${xunit_filename}\n    COMMAND "${script} --gtest_output=xml:${test_output_dir}/${xunit_filename}"\n    DEPENDENCIES ${target}\n    WORKING_DIRECTORY ${ARG_WORKING_DIRECTORY})\nendfunction()\n')),(0,s.kt)("p",null,"It takes the same arguments as ",(0,s.kt)("inlineCode",{parentName:"p"},"add_lisp_executable"),", uses rostest to run the generated executable."),(0,s.kt)("p",null,"The whole implementation mentioned in this page can be found in the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/wty-andrew/clownbot/tree/master/clownbot_common/testing"},"clownbot_common")," package. We should now have a testing setup that integrates well with ROS."),(0,s.kt)("div",{className:"footnotes"},(0,s.kt)("hr",{parentName:"div"}),(0,s.kt)("ol",{parentName:"div"},(0,s.kt)("li",{parentName:"ol",id:"fn-1"},"See ",(0,s.kt)("a",{parentName:"li",href:"https://github.com/google/googletest/blob/master/googletest/docs/advanced.md#generating-an-xml-report"},"here")," and ",(0,s.kt)("a",{parentName:"li",href:"https://llg.cubic.org/docs/junit/"},"here")," for detailed description of the JUnit XML reporting format",(0,s.kt)("a",{parentName:"li",href:"#fnref-1",className:"footnote-backref"},"\u21a9")))))}u.isMDXComponent=!0}}]);